<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 生活、學習紀錄</title>
        <link>https://chuni-lin.github.io/posts/</link>
        <description>Recent content in Posts on 生活、學習紀錄</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Mon, 23 Nov 2020 21:29:07 +0800</lastBuildDate>
        <atom:link href="https://chuni-lin.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>What Is Event Loop</title>
            <link>https://chuni-lin.github.io/posts/2020/11/what-is-event-loop/</link>
            <pubDate>Mon, 23 Nov 2020 21:29:07 +0800</pubDate>
            
            <guid>https://chuni-lin.github.io/posts/2020/11/what-is-event-loop/</guid>
            <description>究竟什麼是 event loop Event loop 就字面上的意思來解釋就是「事件圈」。用我的理解來說就是事件的發生順序。但在 JavaScript 中，事件的發生順序卻與我們所以為的有那麼一點不同。而這也就是這篇筆記的主旨，讓我們來好好來了解究竟 event loop 是如何發生在 JavaScript 執行程序中的。進入正題之前，先來認識幾個有點陌生的單字。
名詞解釋 單執行緒（Single-Threaded） JavaScript 是單執行緒的程式語言，白話來說就是由上而下一行一行地執行、一次只做一件事。
堆疊區（Stack） JavaScript 會將執行的程式放到 stack 中，代表他目前正處理到哪個段落。如下圖所示，JavaScript 會放到 stack 中，然後一行一行地執行。而執行到 return 時，他會直接脫離堆疊。  [圖片來源][https://www.youtube.com/watch?v=8aghzqkofbq&amp;amp;feature=emb_title]
 事件佇列（Task Queue, Callback Queue） 有一些無法預期什麼時候會被執行的操作，像是 setTimeout、event 監聽器、Ajax，在 JavaScript 中都會以非同步的方式被處理。也就是先被放到事件佇列，等到同步執行的程式碼執行完，再回過頭來處理那些被放到佇列中的任務。  [圖片來源][https://medium.com/@rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd]
 所以，到底什麼是 event loop JavazScript 在執行函式的順序是這樣的：
 將函式放到堆疊區（Stack）中 如果有非同步的處理程式，例如上述的 setTimeout、event 監聽器、Ajax，會先被放到事件佇列(Callback Queue) 等到堆疊區（Stack）中執行完畢後，再將事件佇列(Callback Queue)中等待執行的任務丟到堆疊區（Stack）中 執行完堆疊區（Stack）中的任務後，再回到事件佇列(Callback Queue)查看是否還有任務要做   [color=#E53A40]這個過程就是 event loop！ [color=#E53A40]第 3 步驟是我們下一步解題的關鍵，多閱讀幾次，放到你心中。
 拆解 setTimeout 函式的謎題 用範例會更好理解，首先我們輸入：</description>
            <content type="html"><![CDATA[<h1 id="究竟什麼是-event-loop">究竟什麼是 event loop</h1>
<p>Event loop 就字面上的意思來解釋就是「事件圈」。用我的理解來說就是事件的發生順序。但在 JavaScript 中，事件的發生順序卻與我們所以為的有那麼一點不同。而這也就是這篇筆記的主旨，讓我們來好好來了解究竟 event loop 是如何發生在 JavaScript 執行程序中的。進入正題之前，先來認識幾個有點陌生的單字。</p>
<h2 id="名詞解釋">名詞解釋</h2>
<h3 id="單執行緒single-threaded">單執行緒（Single-Threaded）</h3>
<p>JavaScript 是單執行緒的程式語言，白話來說就是由上而下一行一行地執行、一次只做一件事。</p>
<h3 id="堆疊區stack">堆疊區（Stack）</h3>
<p>JavaScript 會將執行的程式放到 stack 中，代表他目前正處理到哪個段落。如下圖所示，JavaScript 會放到 stack 中，然後一行一行地執行。而執行到 return 時，他會直接脫離堆疊。
<img src="https://i.imgur.com/Jx00yaG.png" alt=""></p>
<blockquote>
<p>[圖片來源][https://www.youtube.com/watch?v=8aghzqkofbq&amp;feature=emb_title]</p>
</blockquote>
<h3 id="事件佇列task-queue-callback-queue">事件佇列（Task Queue, Callback Queue）</h3>
<p>有一些無法預期什麼時候會被執行的操作，像是 setTimeout、event 監聽器、Ajax，在 JavaScript 中都會以非同步的方式被處理。也就是先被放到事件佇列，等到同步執行的程式碼執行完，再回過頭來處理那些被放到佇列中的任務。
<img src="https://miro.medium.com/max/1400/1*iHhUyO4DliDwa6x_cO5E3A.gif" alt=""></p>
<blockquote>
<p>[圖片來源][https://medium.com/@rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd]</p>
</blockquote>
<h2 id="所以到底什麼是-event-loop">所以，到底什麼是 event loop</h2>
<p>JavazScript 在執行函式的順序是這樣的：</p>
<ol>
<li>將函式放到堆疊區（Stack）中</li>
<li>如果有非同步的處理程式，例如上述的 setTimeout、event 監聽器、Ajax，會先被放到事件佇列(Callback Queue)</li>
<li>等到堆疊區（Stack）中執行完畢後，再將事件佇列(Callback Queue)中等待執行的任務丟到堆疊區（Stack）中</li>
<li>執行完堆疊區（Stack）中的任務後，再回到事件佇列(Callback Queue)查看是否還有任務要做</li>
</ol>
<blockquote>
<p>[color=#E53A40]這個過程就是 event loop！
[color=#E53A40]第 3 步驟是我們下一步解題的關鍵，多閱讀幾次，放到你心中。</p>
</blockquote>
<h2 id="拆解-settimeout-函式的謎題">拆解 setTimeout 函式的謎題</h2>
<p>用範例會更好理解，首先我們輸入：</p>
<pre><code class="language-javascript=" data-lang="javascript=">setTimeout(function() {console.log('delay 0 sec')}, 0)
console.log('Hello!')
</code></pre><p>得到這樣的結果：</p>
<pre><code class="language-javascript=" data-lang="javascript=">Hello!
delay 0 sec
</code></pre><p>可以發現 Hello! 比起設置了 0 秒的 setTimeout 函式更早出現，為什麼呢？讓我們套用上述的流程，就可以一覽無遺。</p>
<ol>
<li>setTimeout 函式被放入堆疊區（Stack）中</li>
<li>由於 setTimeout 屬於非同步處理程式，因此在堆疊區（Stack）中跑完設定的時間後，會被移到事件佇列(Callback Queue)待機</li>
<li>console.log(&lsquo;Hello!')被放入堆疊區（Stack）中</li>
<li>堆疊區（Stack）中的 console.log(&lsquo;Hello!') 被執行</li>
<li>印出 console.log(&lsquo;Hello!')結果</li>
<li>此時，堆疊區（Stack）已經沒有任何任務，將 setTimeout 函式從事件佇列(Callback Queue)中拿出來執行</li>
<li>印出 setTimeout 結果</li>
</ol>
<p><strong>由上面的過程，我們可以推論「setTimeout 設定的等待時間，其實並不能保證它會在設定的時間一到就被執行，JavaScript 引擎要先確定堆疊區（Stack）中的任務都執行完後，才會再回過頭來處理事件佇列(Callback Queue)中的任務。假設我們設定時間為 0sec，只能說它會在大於等於 0sec 後才會執行。」</strong></p>
<h2 id="參考資料">參考資料</h2>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;feature=emb_title">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a> &gt; <a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a> &gt; <a href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd">Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript</a> &gt; <a href="https://medium.com/@jonathan_wong/what-are-javascript-event-loops-30c72a6ab674">What are Event Loops and What Does It Have to Do with JavaScript?</a> &gt; <a href="https://ithelp.ithome.com.tw/articles/10200054">單執行緒&amp;非同步發生的血案</a></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Alpha Camp 學期 2-1 學習心得</title>
            <link>https://chuni-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-1-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</link>
            <pubDate>Sun, 22 Nov 2020 14:16:53 +0800</pubDate>
            
            <guid>https://chuni-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-1-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</guid>
            <description>為什麼開始寫網頁？ 在工作中偶然有機會要製作一個網頁，當時由於經費的問題，必須自己搞定這個任務。於是就從一本厚重的 HTML、CSS 書籍開始，從學習到刻出一個靜態頁面。當時是在 wordpress 平台上操作，所以基本上不需要太多深入的技巧，頂多改動一下 CSS。不過就因為這次的經驗，讓我對「寫網頁」這件事有了興趣，後來持續自己精進，在某一次的產品計畫中提出希望能自己做出這個產品的 Brand Page。然後從伺服器開始，一直到客戶端的整個過程，使用 Google 大神的資訊漸漸把知識拼圖拼起來。後來發現有 Bootstrap 這個能夠快速拼出網頁模版的平台，一邊使用內建的功能，一邊加入自己的 CSS，終於把一個完整的品牌頁面刻出來。那時候的成就感真是像潮水湧出。
為什麼想學習 JS？ 在跳進這個坑之後，發現原來這是個很深很深看不到最下面的坑。開始開啟開發者工具去看喜歡的網頁的程式碼，試著去理解他的邏輯，然後也想做出跟他一樣的互動效果。結果發現原來這都需要 JS。用 CSS 或許也可以做出動畫效果，但要真正的與使用者互動，非 JS 莫屬。與 HTML、CSS 不同，JS 是一個程式語言，他較為複雜的邏輯概念讓我無法有效率地自己學習，但我想讓品牌網頁更有互動性、更完整，於是我開始尋找線上課程。
所以學了幾個月，有什麼感受？ 我是在學完學期 2-2 才回過頭來做這個 review，原因是當時學完 2-1 時，對 JS 只有初步的了解，沒有一個宏觀、完整的認識，所以無法整理出太多內化的知識。在跑過 API、DOM 及前端使用者體驗後，從一開始覺得這是一個很難理解的程式語言，到現在開始發現他的趣味所在。原本我猜想要學會 JS，大概數學、邏輯能力要很好，後來發現其實不盡然如此。當然在一開始不習慣要如何去思考它時，會顯得自己很笨拙，但跟著課程循序漸進地拆解後，才發現真正重要的，不是「有沒有解題的能力」，而是「如何去思考它運作的能力。」這再次向我說明了，邏輯是要柔軟去對待而不是用死背來應付的。你可以背很多語法，但當你沒掌握到整個撰寫程式的思考脈絡時，你會發現語法就只是語法，而不是解決問題的工具。JS 真的是一門博大精深的語言，有很多可以探索的部分，當你在拆解每一個步驟時，都可以感受到設計者在 JS 引擎上所做的巧思。</description>
            <content type="html"><![CDATA[<h3 id="為什麼開始寫網頁">為什麼開始寫網頁？</h3>
<p>在工作中偶然有機會要製作一個網頁，當時由於經費的問題，必須自己搞定這個任務。於是就從一本厚重的 HTML、CSS 書籍開始，從學習到刻出一個靜態頁面。當時是在 wordpress 平台上操作，所以基本上不需要太多深入的技巧，頂多改動一下 CSS。不過就因為這次的經驗，讓我對「寫網頁」這件事有了興趣，後來持續自己精進，在某一次的產品計畫中提出希望能自己做出這個產品的 Brand Page。然後從伺服器開始，一直到客戶端的整個過程，使用 Google 大神的資訊漸漸把知識拼圖拼起來。後來發現有 Bootstrap 這個能夠快速拼出網頁模版的平台，一邊使用內建的功能，一邊加入自己的 CSS，終於把一個完整的品牌頁面刻出來。那時候的成就感真是像潮水湧出。</p>
<h3 id="為什麼想學習-js">為什麼想學習 JS？</h3>
<p>在跳進這個坑之後，發現原來這是個很深很深看不到最下面的坑。開始開啟開發者工具去看喜歡的網頁的程式碼，試著去理解他的邏輯，然後也想做出跟他一樣的互動效果。結果發現原來這都需要 JS。用 CSS 或許也可以做出動畫效果，但要真正的與使用者互動，非 JS 莫屬。與 HTML、CSS 不同，JS 是一個程式語言，他較為複雜的邏輯概念讓我無法有效率地自己學習，但我想讓品牌網頁更有互動性、更完整，於是我開始尋找線上課程。</p>
<h3 id="所以學了幾個月有什麼感受">所以學了幾個月，有什麼感受？</h3>
<p>我是在學完學期 2-2 才回過頭來做這個 review，原因是當時學完 2-1 時，對 JS 只有初步的了解，沒有一個宏觀、完整的認識，所以無法整理出太多內化的知識。在跑過 API、DOM 及前端使用者體驗後，從一開始覺得這是一個很難理解的程式語言，到現在開始發現他的趣味所在。原本我猜想要學會 JS，大概數學、邏輯能力要很好，後來發現其實不盡然如此。當然在一開始不習慣要如何去思考它時，會顯得自己很笨拙，但跟著課程循序漸進地拆解後，才發現真正重要的，不是「有沒有解題的能力」，而是「<strong>如何去思考它運作的能力</strong>。」這再次向我說明了，邏輯是要柔軟去對待而不是用死背來應付的。你可以背很多語法，但當你沒掌握到整個撰寫程式的思考脈絡時，你會發現語法就只是語法，而不是解決問題的工具。JS 真的是一門博大精深的語言，有很多可以探索的部分，當你在拆解每一個步驟時，都可以感受到設計者在 JS 引擎上所做的巧思。</p>
]]></content>
        </item>
        
    </channel>
</rss>
